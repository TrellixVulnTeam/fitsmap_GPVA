<!DOCTYPE html>
<html>
<head>
    <title>test</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin=""/>
    <link rel='stylesheet' href='https://unpkg.com/leaflet-search@2.9.8/dist/leaflet-search.src.css'/>
    <link rel='stylesheet' href='css/MarkerCluster.Default.css'/>
    <link rel='stylesheet' href='css/MarkerCluster.css'/>
    <link rel='stylesheet' href='css/TileNearestNeighbor.css'/>
    <script src='https://unpkg.com/leaflet@1.3.4/dist/leaflet.js' integrity='sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA==' crossorigin=''></script>
    <script src='https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster-src.js' crossorigin=''></script>
    <script src='https://unpkg.com/leaflet-search@2.9.8/dist/leaflet-search.src.js' crossorigin=''></script>
    <script src='js/test_marker'></script>
    <script src='js/l.ellipse.min.js'></script>
    <style>
        html, body {
        height: 100%;
        margin: 0;
        }
        #map {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script>
    L.CRS.FitsMap = L.extend({}, L.CRS.Simple, {
        transformation: new L.Transformation(1/2, 0, -1/2, 256)
    });
    var layerControl = L.control.layers();
    var map = L.map("map", {
        crs: L.CRS.FitsMap,
        minZoom: 0,
        preferCanvas: true,
    });
    const test_layer = L.tileLayer("test_layer/{z}/{y}/{x}.png", { attribution:"<a href='https://github.com/ryanhausen/fitsmap'>FitsMap</a>",minZoom: 0,maxZoom: 6,maxNativeZoom: 1,}).addTo(map);
    asyncLayers = [
    ];
    function loadNextLayer(event) {
        if (asyncLayers.length > 0){
            nextLayer = asyncLayers.pop()
            nextLayer[1].on("load", loadNextLayer);
            layerControl.addBaseLayer(nextLayer[1], nextLayer[0]);
        }
    };
    test_layer.on("load", loadNextLayer);
    // catalogs ================================================================
    // a preset list of colors to use for markers in different catalogs
    let colors = [
        "#4C72B0",
        "#DD8452",
        "#55A868",
        "#C44E52",
        "#8172B3",
        "#937860",
        "#DA8BC3",
        "#8C8C8C",
        "#CCB974",
        "#64B5CD",
    ];

    // each list will hold the markers. if a catalog is sharded then there
    // will be multiple lists in a each top-level list element.
    var markerList = [
        [[]],
    ];

    // the variables containing the catalog information, this mirrors the
    // structre in `markerList`. the sources in these variables will be
    // converted into markers and then added to the corresponding array
    const collections = [
        [test_cat_var_0],
    ];
    var labels = [
        '<span style="color:red">test</span>::0/'+ 1 +'-0%',
    ];

    // `collections_idx` is a collection of indexes that can be popped to
    // asynchronously process the catalog data in `collections`
    collection_idx = []
    for (var i = 0; i < collections.length; i++){
        collection_idx.push([...Array(collections[i].length).keys()])
    }

    // declare markers up here for scope
    var markers = [];

    // this is a function that returns a callback function for the chunked
    // loading function of markerClusterGroups
    function update_f(i){
        //console.log("update_f", i);

        // the markerClusterGroups callback function takes three arguments
        // nMarkers: number of markers processed so far
        // total:    total number of markers in shard
        // elapsed:  time elapsed (not used)
        return (nMarkers, total, elasped) => {

            var completetion = total==0 ? 0 : nMarkers/total;

            name_tag = layerControl._layers[i].name;
            split_values = name_tag.split("::");
            html_name = split_values[0];
            progress = split_values[1];

            current_iter = parseInt(progress.split("/")[0]) + Math.floor(completetion);
            total_iter = parseInt(progress.split("/")[1].split("-")[0]);
            html_name = name_tag.split("::")[0];

            if (completetion==1 && current_iter==total_iter){
                layerControl._layers[i].name = html_name.replace("red", "black");
            }
            else {
                layerControl._layers[i].name = html_name + "::" + current_iter + "/" + total_iter + "-" + Math.floor(completetion*100) + "%";
            }
            layerControl._update();

            // if we have finished processing move on to the next shard/catalog
            if (completetion==1){
                add_marker_collections_f(i);
            }
        }
    };

    const panes = [
        "test",
    ];
    panes.forEach(i => {map.createPane(i).style.zIndex = 0;});

    for (var i = 0; i < panes.length; i++){
        markers.push(
            L.markerClusterGroup({'chunkedLoading':true, 'chunkInterval':50, 'chunkDelay':50, 'chunkProgress':update_f(i), 'clusterPane':panes[i]}),
        );
    }

    for (var i = 0; i < markers.length; i++){
        layerControl.addOverlay(markers[i], labels[i]);
    }

    function add_marker_collections(event){
        add_marker_collections_f(collection_idx.length-1);
    }

    function add_marker_collections_f(i){
        //console.log('i is currently ', i);
        if (i >= 0){
            if (collection_idx[i].length > 0) {
                j = collection_idx[i].pop();
                markers[i].addLayers(markerList[i][j]);
            } else {
                markers[i].options.chunkProgress = null;
                layerControl._update();

                // this for some reason causes an error, but doesn't seem to
                // affect the map.
                map.getPane(panes[i]).style.zIndex=650;
                markers[i].remove();

                add_marker_collections_f(i-1);
            }
        }
    };

    for (i = 0; i < collections.length; i++){
        collection = collections[i];
        //console.log(i, collection);

        for (ii = 0; ii < collection.length; ii++){
            collec = collection[ii];
            for (j = 0; j < collec.length; j++){
                src = collec[j];

                var width = (((src.widest_col * 10) * src.n_cols) + 10).toString() + 'em';
                var include_img = src.include_img ? 2 : 1;
                var height = ((src.n_rows + 1) * 15 * (include_img)).toString() + 'em';

                let p = L.popup({ maxWidth: "auto" })
                         .setLatLng([src.y, src.x])
                         .setContent("<iframe src='catalog_assets/" + src.cat_path + "/" + src.catalog_id + ".html' width='" + width + "' height='" + height + "'></iframe>");

                let marker;
                if (src.a==-1){
                    marker = L.circleMarker([src.y, src.x], {
                        catalog_id: panes[i] + ':' + src.catalog_id + ':',
                        color: colors[i % colors.length]
                    }).bindPopup(p);
                } else {
                    marker = L.ellipse([src.y, src.x], [src.a, src.b], (src.theta * (180/Math.PI) * -1), {
                        catalog_id: panes[i] + ':' + src.catalog_id + ':',
                        color: colors[i % colors.length]
                    }).bindPopup(p);
                }

                markerList[i][ii].push(marker);
            }
        }
    }

    map.on("load", add_marker_collections);
    var marker_layers = L.layerGroup(markers);
    // =========================================================================
    // search function =========================================================
    function searchHelp(e) {
        map.setView(e.latlng, 4);
        e.layer.addTo(map);
    };

    var searchBar = L.control.search({
        layer: marker_layers,
        initial: false,
        propertyName: 'catalog_id',
        textPlaceholder: 'Enter catalog_id ID',
        hideMarkerOnCollapse: true,
    });

    searchBar.on('search:locationfound', searchHelp);
    searchBar.addTo(map);
    // =========================================================================
    layerControl.addBaseLayer(test_layer, "test_layer");
    layerControl.addTo(map);
    map.fitWorld({"maxZoom":map.getMinZoom()});
    </script>
</body>
</html>